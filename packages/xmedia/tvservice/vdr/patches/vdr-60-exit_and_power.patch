diff -Naurp vdr-2.4.0/keys.c vdr-2.4.0-patch/keys.c
--- vdr-2.4.0/keys.c	2012-12-04 14:52:52.000000000 +0200
+++ vdr-2.4.0-patch/keys.c	2018-04-16 11:04:41.000000000 +0300
@@ -43,6 +43,8 @@ static tKey keyTable[] = { // "Up" and "
                     { kNext,          trNOOP("Key$Next")        },
                     { kPrev,          trNOOP("Key$Prev")        },
                     { kPower,         trNOOP("Key$Power")       },
+                    { kExit,          trNOOP("Key$Exit")        },
+                    { kSleep,         trNOOP("Key$Sleep")       },
                     { kChanUp,        trNOOP("Key$Channel+")    },
                     { kChanDn,        trNOOP("Key$Channel-")    },
                     { kChanPrev,      trNOOP("Key$PrevChannel") },
diff -Naurp vdr-2.4.0/keys.h vdr-2.4.0-patch/keys.h
--- vdr-2.4.0/keys.h	2015-01-27 12:45:18.000000000 +0200
+++ vdr-2.4.0-patch/keys.h	2018-04-16 11:04:41.000000000 +0300
@@ -37,6 +37,8 @@ enum eKeys { // "Up" and "Down" must be
              kNext,
              kPrev,
              kPower,
+             kExit,
+             kSleep,
              kChanUp,
              kChanDn,
              kChanPrev,
diff -Naurp vdr-2.4.0/menu.c vdr-2.4.0-patch/menu.c
--- vdr-2.4.0/menu.c	2018-04-16 11:03:57.000000000 +0300
+++ vdr-2.4.0-patch/menu.c	2018-04-16 11:04:41.000000000 +0300
@@ -14,6 +14,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
+#include <fcntl.h>
 #include "channels.h"
 #include "config.h"
 #include "cutter.h"
@@ -2174,28 +2175,60 @@ eOSState cMenuCommands::Execute(void)
               cmdbuf = cString::sprintf("%s %s", *command, *parameters);
            const char *cmd = *cmdbuf ? *cmdbuf : *command;
            dsyslog("executing command '%s'", cmd);
-           cPipe p;
-           if (p.Open(cmd, "r")) {
-              int l = 0;
-              int c;
-              while ((c = fgetc(p)) != EOF) {
-                    if (l % 20 == 0) {
-                       if (char *NewBuffer = (char *)realloc(result, l + 21))
-                          result = NewBuffer;
-                       else {
-                          esyslog("ERROR: out of memory");
-                          break;
-                          }
-                       }
-                    result[l++] = char(c);
-                    }
-              if (result)
-                 result[l] = 0;
-              p.Close();
-              }
+           if (strcmp(cmd, "exit") == 0)
+           {
+               remove("/var/lock/start.vdr");
+               creat("/var/lock/start.kodi", S_IRUSR|S_IROTH);
+               esyslog("VDR frontend command: Exit");
+               ShutdownHandler.Exit(0);
+           }
+           else if (strcmp(cmd, "sleep") == 0)
+           {
+               remove("/var/lock/start.vdr");
+               creat("/var/lock/sleep.vdr", S_IRUSR|S_IROTH);
+               esyslog("VDR frontend command: Sleep");
+               ShutdownHandler.Exit(97);
+           }
+           else if (strcmp(cmd, "sysreboot") == 0)
+           {
+               remove("/var/lock/start.vdr");
+               creat("/var/lock/reboot.vdr", S_IRUSR|S_IROTH);
+               esyslog("VDR frontend command: Reboot");
+               ShutdownHandler.Exit(98);
+           }
+           else if (strcmp(cmd, "syspower") == 0)
+           {
+               remove("/var/lock/start.vdr");
+               creat("/var/lock/power.vdr", S_IRUSR|S_IROTH);
+               esyslog("VDR frontend command: Powerof");
+               ShutdownHandler.Exit(99);
+           }
            else
-              esyslog("ERROR: can't open pipe for command '%s'", cmd);
-           Skins.Message(mtStatus, NULL);
+           {
+               cPipe p;
+               if (p.Open(cmd, "r")) {
+                  int l = 0;
+                  int c;
+                  while ((c = fgetc(p)) != EOF) {
+                      if (l % 20 == 0) {
+                         if (char *NewBuffer = (char *)realloc(result, l + 21))
+                            result = NewBuffer;
+                         else {
+                            esyslog("ERROR: out of memory");
+                            break;
+                            }
+                         }
+                      result[l++] = char(c);
+                      }
+                  if (result)
+                     result[l] = 0;
+                  p.Close();
+                  }
+               else
+                  esyslog("ERROR: can't open pipe for command '%s'", cmd);
+               Skins.Message(mtStatus, NULL);
+           }
+
            if (result)
               return AddSubMenu(new cMenuText(title, result, fontFix));
            return osEnd;
diff -Naurp vdr-2.4.0/menu.c.orig vdr-2.4.0-patch/menu.c.orig
--- vdr-2.4.0/menu.c.orig	2018-04-14 13:24:41.000000000 +0300
+++ vdr-2.4.0-patch/menu.c.orig	2018-04-16 11:04:41.000000000 +0300
@@ -3821,6 +3821,12 @@ void cMenuSetupLNB::Setup(void)
      Add(new cMenuEditIntxItem(tr("Setup.LNB$Positioner speed (degrees/s)"), &data.PositionerSpeed, 1, 1800, 10));
      }
 
+  Add(new cMenuEditBoolItem(tr("Setup.LNB$Enable power saving"), &data.PowerdownEnabled));
+  if (data.PowerdownEnabled) {
+     Add(new cMenuEditIntItem(tr("Setup.LNB$Power down an idle device after (sec)"), &data.PowerdownTimeoutS));
+     Add(new cMenuEditIntItem(tr("Setup.LNB$Wake up from power-down after (h)"), &data.PowerdownWakeupH));
+     }
+
   SetCurrent(Get(current));
   Display();
 }
@@ -3829,6 +3835,7 @@ eOSState cMenuSetupLNB::ProcessKey(eKeys
 {
   int oldDiSEqC = data.DiSEqC;
   int oldUsePositioner = data.UsePositioner;
+  int oldPowerdownEnabled = data.PowerdownEnabled;
   bool DeviceBondingsChanged = false;
   if (Key == kOk) {
      cString NewDeviceBondings = satCableNumbers.ToString();
@@ -3837,7 +3844,7 @@ eOSState cMenuSetupLNB::ProcessKey(eKeys
      }
   eOSState state = cMenuSetupBase::ProcessKey(Key);
 
-  if (Key != kNone && (data.DiSEqC != oldDiSEqC || data.UsePositioner != oldUsePositioner))
+  if (Key != kNone && (data.DiSEqC != oldDiSEqC || data.UsePositioner != oldUsePositioner || data.PowerdownEnabled != oldPowerdownEnabled))
      Setup();
   else if (DeviceBondingsChanged)
      cDvbDevice::BondDevices(data.DeviceBondings);
diff -Naurp vdr-2.4.0/po/ru_RU.po vdr-2.4.0-patch/po/ru_RU.po
--- vdr-2.4.0/po/ru_RU.po	2018-04-14 14:01:56.000000000 +0300
+++ vdr-2.4.0-patch/po/ru_RU.po	2018-04-16 11:07:55.000000000 +0300
@@ -1597,12 +1597,24 @@ msgstr "Запустить запись?
 msgid "Recording started"
 msgstr "Запись начата"
 
-msgid "VDR will shut down later - press Power to force"
-msgstr "VDR выключится позже - нажмите Питание для ускорения"
+msgid "MediaCenter will shut down later - press Power to force"
+msgstr "Медиацентр выключится позже - нажмите Power для ускорения"
+
+msgid "VDR will close later - press Exit to force"
+msgstr "VDR будет закрыт позже - нажмите Exit для ускорения"
+
+msgid "MediaCenter will sleep later - press Sleep to force"
+msgstr "Медиацентр будет переведен в сон позже - нажмите Sleep для ускорения"
 
 msgid "Press any key to cancel shutdown"
 msgstr "Нажмите любую кнопку чтобы отменить выключение"
 
+msgid "Press any key to cancel exit"
+msgstr "Нажмите любую кнопку чтобы отменить переключение в KODI."
+
+msgid "Press any key to cancel sleep"
+msgstr "Нажмите любую кнопку чтобы отменить режим сна."
+
 msgid "Editing process failed!"
 msgstr "Ошибка во время монтажа записи!"
 
diff -Naurp vdr-2.4.0/shutdown.c vdr-2.4.0-patch/shutdown.c
--- vdr-2.4.0/shutdown.c	2018-03-23 17:39:21.000000000 +0200
+++ vdr-2.4.0-patch/shutdown.c	2018-04-16 11:04:41.000000000 +0300
@@ -127,9 +127,10 @@ void cShutdownHandler::SetShutdownComman
 void cShutdownHandler::CallShutdownCommand(time_t WakeupTime, int Channel, const char *File, bool UserShutdown)
 {
   time_t Delta = WakeupTime ? WakeupTime - time(NULL) : 0;
-  cString cmd = cString::sprintf("%s %ld %ld %d \"%s\" %d", shutdownCommand, WakeupTime, Delta, Channel, *strescape(File, "\\\"$"), UserShutdown);
+  cString cmd = cString::sprintf("PowerOFF: %ld %ld %d \"%s\" %d", WakeupTime, Delta, Channel, *strescape(File, "\\\"$"), UserShutdown);
   isyslog("executing '%s'", *cmd);
-  int Status = SystemExec(cmd, true);
+  remove("/var/lock/start.vdr");
+  int Status = SystemExec("systemctl poweroff", true);
   if (!WIFEXITED(Status) || WEXITSTATUS(Status))
      esyslog("SystemExec() failed with status %d", Status);
   else {
@@ -159,11 +160,6 @@ bool cShutdownHandler::ConfirmShutdown(b
   if (!Interactive && !cRemote::Enabled())
      return false;
 
-  if (!shutdownCommand) {
-     if (Interactive)
-        Skins.Message(mtError, tr("Can't shutdown - option '-s' not given!"));
-     return false;
-     }
   if (RecordingsHandler.Active()) {
      if (!Interactive || !Interface->Confirm(tr("Editing - shut down anyway?")))
         return false;
diff -Naurp vdr-2.4.0/shutdown.c.orig vdr-2.4.0-patch/shutdown.c.orig
--- vdr-2.4.0/shutdown.c.orig	1970-01-01 03:00:00.000000000 +0300
+++ vdr-2.4.0-patch/shutdown.c.orig	2018-03-23 17:39:21.000000000 +0200
@@ -0,0 +1,269 @@
+/*
+ * shutdown.c: Handling of shutdown and inactivity
+ *
+ * See the main source file 'vdr.c' for copyright information and
+ * how to reach the author.
+ *
+ * Original version written by Udo Richter <udo_richter@gmx.de>.
+ *
+ * $Id: shutdown.c 4.2 2018/03/23 15:39:21 kls Exp $
+ */
+
+#include "shutdown.h"
+#include <stdio.h>
+#include <stdlib.h>
+#include <sys/types.h>
+#include <sys/wait.h>
+#include "channels.h"
+#include "config.h"
+#include "i18n.h"
+#include "interface.h"
+#include "menu.h"
+#include "plugin.h"
+#include "recording.h"
+#include "timers.h"
+#include "tools.h"
+
+cShutdownHandler ShutdownHandler;
+
+cCountdown::cCountdown(void)
+{
+  timeout = 0;
+  counter = 0;
+  timedOut = false;
+  message = NULL;
+}
+
+void cCountdown::Start(const char *Message, int Seconds)
+{
+  timeout = time(NULL) + Seconds;
+  counter = -1;
+  timedOut = false;
+  message = Message;
+  Update();
+}
+
+void cCountdown::Cancel(void)
+{
+  if (timeout) {
+     timeout = 0;
+     timedOut = false;
+     Skins.Message(mtStatus, NULL);
+     }
+}
+
+bool cCountdown::Done(void)
+{
+  if (timedOut) {
+     Cancel();
+     return true;
+     }
+  return false;
+}
+
+bool cCountdown::Update(void)
+{
+  if (timeout) {
+     int NewCounter = (timeout - time(NULL) + 9) / 10;
+     if (NewCounter <= 0)
+        timedOut = true;
+     if (counter != NewCounter) {
+        counter = NewCounter;
+        Skins.Message(mtStatus, cString::sprintf(message, *cString::sprintf("%d:%d0", counter > 0 ? counter / 6 : 0, counter > 0 ? counter % 6 : 0)));
+        return true;
+        }
+     }
+  return false;
+}
+
+cShutdownHandler::cShutdownHandler(void)
+{
+  activeTimeout = 0;
+  retry = 0;
+  shutdownCommand = NULL;
+  exitCode = -1;
+  emergencyExitRequested = false;
+}
+
+cShutdownHandler::~cShutdownHandler()
+{
+  free(shutdownCommand);
+}
+
+void cShutdownHandler::RequestEmergencyExit(void)
+{
+  if (Setup.EmergencyExit) {
+     esyslog("initiating emergency exit");
+     emergencyExitRequested = true;
+     Exit(1);
+     }
+  else
+     dsyslog("emergency exit request ignored according to setup");
+}
+
+void cShutdownHandler::CheckManualStart(int ManualStart)
+{
+  time_t Delta = Setup.NextWakeupTime ? Setup.NextWakeupTime - time(NULL) : 0;
+
+  if (!Setup.NextWakeupTime || abs(Delta) > ManualStart) {
+     // Apparently the user started VDR manually
+     dsyslog("assuming manual start of VDR");
+     // Set inactive after MinUserInactivity
+     SetUserInactiveTimeout();
+     }
+  else {
+     // Set inactive from now on
+     dsyslog("scheduled wakeup time in %ld minutes, assuming automatic start of VDR", Delta / 60);
+     SetUserInactiveTimeout(-3, true);
+     }
+}
+
+void cShutdownHandler::SetShutdownCommand(const char *ShutdownCommand)
+{
+  free(shutdownCommand);
+  shutdownCommand = ShutdownCommand ? strdup(ShutdownCommand) : NULL;
+}
+
+void cShutdownHandler::CallShutdownCommand(time_t WakeupTime, int Channel, const char *File, bool UserShutdown)
+{
+  time_t Delta = WakeupTime ? WakeupTime - time(NULL) : 0;
+  cString cmd = cString::sprintf("%s %ld %ld %d \"%s\" %d", shutdownCommand, WakeupTime, Delta, Channel, *strescape(File, "\\\"$"), UserShutdown);
+  isyslog("executing '%s'", *cmd);
+  int Status = SystemExec(cmd, true);
+  if (!WIFEXITED(Status) || WEXITSTATUS(Status))
+     esyslog("SystemExec() failed with status %d", Status);
+  else {
+     Setup.NextWakeupTime = WakeupTime; // Remember this wakeup time for comparison on reboot
+     Setup.Save();
+     }
+}
+
+void cShutdownHandler::SetUserInactiveTimeout(int Seconds, bool Force)
+{
+  if (!Setup.MinUserInactivity && !Force) {
+     activeTimeout = 0;
+     return;
+     }
+  if (Seconds >= 0)
+     activeTimeout = time(NULL) + Seconds;
+  else if (Seconds == -1)
+     activeTimeout = time(NULL) + Setup.MinUserInactivity * 60;
+  else if (Seconds == -2)
+     activeTimeout = 0;
+  else if (Seconds == -3)
+     activeTimeout = 1;
+}
+
+bool cShutdownHandler::ConfirmShutdown(bool Interactive)
+{
+  if (!Interactive && !cRemote::Enabled())
+     return false;
+
+  if (!shutdownCommand) {
+     if (Interactive)
+        Skins.Message(mtError, tr("Can't shutdown - option '-s' not given!"));
+     return false;
+     }
+  if (RecordingsHandler.Active()) {
+     if (!Interactive || !Interface->Confirm(tr("Editing - shut down anyway?")))
+        return false;
+     }
+
+  LOCK_TIMERS_READ;
+  const cTimer *Timer = Timers->GetNextActiveTimer();
+  time_t Next = Timer ? Timer->StartTime() : 0;
+  time_t Delta = Timer ? Next - time(NULL) : 0;
+
+  if (cRecordControls::Active() || (Next && Delta <= 0)) {
+     // VPS recordings in timer end margin may cause Delta <= 0
+     if (!Interactive || !Interface->Confirm(tr("Recording - shut down anyway?")))
+        return false;
+     }
+  else if (Next && Delta <= Setup.MinEventTimeout * 60) {
+     // Timer within Min Event Timeout
+     if (!Interactive)
+        return false;
+     cString buf = cString::sprintf(tr("Recording in %ld minutes, shut down anyway?"), Delta / 60);
+     if (!Interface->Confirm(buf))
+        return false;
+     }
+
+  if (cPluginManager::Active(Interactive ? tr("shut down anyway?") : NULL))
+     return false;
+
+  cPlugin *Plugin = cPluginManager::GetNextWakeupPlugin();
+  Next = Plugin ? Plugin->WakeupTime() : 0;
+  Delta = Next ? Next - time(NULL) : 0;
+  if (Next && Delta <= Setup.MinEventTimeout * 60) {
+     // Plugin wakeup within Min Event Timeout
+     if (!Interactive)
+        return false;
+     cString buf = cString::sprintf(tr("Plugin %s wakes up in %ld min, continue?"), Plugin->Name(), Delta / 60);
+     if (!Interface->Confirm(buf))
+        return false;
+     }
+
+  return true;
+}
+
+bool cShutdownHandler::ConfirmRestart(bool Interactive)
+{
+  if (RecordingsHandler.Active()) {
+     if (!Interactive || !Interface->Confirm(tr("Editing - restart anyway?")))
+        return false;
+     }
+
+  LOCK_TIMERS_READ;
+  const cTimer *Timer = Timers->GetNextActiveTimer();
+  time_t Next = Timer ? Timer->StartTime() : 0;
+  time_t Delta = Timer ? Next - time(NULL) : 0;
+
+  if (cRecordControls::Active() || (Next && Delta <= 0)) {
+     // VPS recordings in timer end margin may cause Delta <= 0
+     if (!Interactive || !Interface->Confirm(tr("Recording - restart anyway?")))
+        return false;
+     }
+
+  if (cPluginManager::Active(Interactive ? tr("restart anyway?") : NULL))
+     return false;
+
+  return true;
+}
+
+bool cShutdownHandler::DoShutdown(bool Force)
+{
+  LOCK_TIMERS_READ;
+  time_t Now = time(NULL);
+  const cTimer *Timer = Timers->GetNextActiveTimer();
+  cPlugin *Plugin = cPluginManager::GetNextWakeupPlugin();
+
+  time_t Next = Timer ? Timer->StartTime() : 0;
+  time_t NextPlugin = Plugin ? Plugin->WakeupTime() : 0;
+  if (NextPlugin && (!Next || Next > NextPlugin)) {
+     Next = NextPlugin;
+     Timer = NULL;
+     }
+  time_t Delta = Next ? Next - Now : 0;
+
+  if (Next && Delta < Setup.MinEventTimeout * 60) {
+     if (!Force)
+        return false;
+     Delta = Setup.MinEventTimeout * 60;
+     Next = Now + Delta;
+     Timer = NULL;
+     dsyslog("reboot at %s", *TimeToString(Next));
+     }
+
+  if (Next && Timer) {
+     dsyslog("next timer event at %s", *TimeToString(Next));
+     CallShutdownCommand(Next, Timer->Channel()->Number(), Timer->File(), Force);
+     }
+  else if (Next && Plugin) {
+     CallShutdownCommand(Next, 0, Plugin->Name(), Force);
+     dsyslog("next plugin wakeup at %s", *TimeToString(Next));
+     }
+  else
+     CallShutdownCommand(Next, 0, "", Force); // Next should always be 0 here. Just for safety, pass it.
+
+  return true;
+}
diff -Naurp vdr-2.4.0/thread.c vdr-2.4.0-patch/thread.c
--- vdr-2.4.0/thread.c	2018-04-16 11:03:57.000000000 +0300
+++ vdr-2.4.0-patch/thread.c	2018-04-16 11:04:41.000000000 +0300
@@ -946,9 +946,13 @@ bool cPipe::Open(const char *Command, co
      }
   if ((pid = fork()) < 0) { // fork failed
      LOG_ERROR;
-     close(fd[0]);
-     close(fd[1]);
-     return false;
+     cCondWait::SleepMs(100);
+     if ((pid = fork()) < 0) {
+         LOG_ERROR;
+         close(fd[0]);
+         close(fd[1]);
+         return false;
+         }
      }
 
   const char *mode = "w";
@@ -1037,7 +1041,11 @@ int SystemExec(const char *Command, bool
 
   if ((pid = fork()) < 0) { // fork failed
      LOG_ERROR;
-     return -1;
+     cCondWait::SleepMs(100);
+     if ((pid = fork()) < 0) {
+        LOG_ERROR;
+        return -1;
+        }
      }
 
   if (pid > 0) { // parent process
diff -Naurp vdr-2.4.0/thread.c.orig vdr-2.4.0-patch/thread.c.orig
--- vdr-2.4.0/thread.c.orig	1970-01-01 03:00:00.000000000 +0300
+++ vdr-2.4.0-patch/thread.c.orig	2018-04-16 11:04:41.000000000 +0300
@@ -0,0 +1,1074 @@
+/*
+ * thread.c: A simple thread base class
+ *
+ * See the main source file 'vdr.c' for copyright information and
+ * how to reach the author.
+ *
+ * $Id: thread.c 4.14 2018/03/05 22:38:10 kls Exp $
+ */
+
+#include "thread.h"
+#include <cxxabi.h>
+#include <dlfcn.h>
+#include <errno.h>
+#include <execinfo.h>
+#include <linux/unistd.h>
+#include <malloc.h>
+#include <stdarg.h>
+#include <stdlib.h>
+#include <sys/prctl.h>
+#include <sys/resource.h>
+#include <sys/syscall.h>
+#include <sys/time.h>
+#include <sys/wait.h>
+#include <unistd.h>
+#include "tools.h"
+
+#define ABORT { dsyslog("ABORT!"); cBackTrace::BackTrace(); abort(); }
+
+//#define DEBUG_LOCKING  // uncomment this line to activate debug output for locking
+#define DEBUG_LOCKSEQ  // uncomment this line to activate debug output for invalid locking sequence
+//#define DEBUG_LOCKCALL // uncomment this line to activate caller information with DEBUG_LOCKSEQ (WARNING: expensive operation, use only when actually debugging the locking sequence!)
+
+#ifdef DEBUG_LOCKING
+#define dbglocking(a...) fprintf(stderr, a)
+#else
+#define dbglocking(a...)
+#endif
+
+static bool GetAbsTime(struct timespec *Abstime, int MillisecondsFromNow)
+{
+  struct timeval now;
+  if (gettimeofday(&now, NULL) == 0) {           // get current time
+     now.tv_sec  += MillisecondsFromNow / 1000;  // add full seconds
+     now.tv_usec += (MillisecondsFromNow % 1000) * 1000;  // add microseconds
+     if (now.tv_usec >= 1000000) {               // take care of an overflow
+        now.tv_sec++;
+        now.tv_usec -= 1000000;
+        }
+     Abstime->tv_sec = now.tv_sec;          // seconds
+     Abstime->tv_nsec = now.tv_usec * 1000; // nano seconds
+     return true;
+     }
+  return false;
+}
+
+// --- cCondWait -------------------------------------------------------------
+
+cCondWait::cCondWait(void)
+{
+  signaled = false;
+  pthread_mutex_init(&mutex, NULL);
+  pthread_cond_init(&cond, NULL);
+}
+
+cCondWait::~cCondWait()
+{
+  pthread_cond_broadcast(&cond); // wake up any sleepers
+  pthread_cond_destroy(&cond);
+  pthread_mutex_destroy(&mutex);
+}
+
+void cCondWait::SleepMs(int TimeoutMs)
+{
+  cCondWait w;
+  w.Wait(max(TimeoutMs, 3)); // making sure the time is >2ms to avoid a possible busy wait
+}
+
+bool cCondWait::Wait(int TimeoutMs)
+{
+  pthread_mutex_lock(&mutex);
+  if (!signaled) {
+     if (TimeoutMs) {
+        struct timespec abstime;
+        if (GetAbsTime(&abstime, TimeoutMs)) {
+           while (!signaled) {
+                 if (pthread_cond_timedwait(&cond, &mutex, &abstime) == ETIMEDOUT)
+                    break;
+                 }
+           }
+        }
+     else
+        pthread_cond_wait(&cond, &mutex);
+     }
+  bool r = signaled;
+  signaled = false;
+  pthread_mutex_unlock(&mutex);
+  return r;
+}
+
+void cCondWait::Signal(void)
+{
+  pthread_mutex_lock(&mutex);
+  signaled = true;
+  pthread_cond_broadcast(&cond);
+  pthread_mutex_unlock(&mutex);
+}
+
+// --- cCondVar --------------------------------------------------------------
+
+cCondVar::cCondVar(void)
+{
+  pthread_cond_init(&cond, 0);
+}
+
+cCondVar::~cCondVar()
+{
+  pthread_cond_broadcast(&cond); // wake up any sleepers
+  pthread_cond_destroy(&cond);
+}
+
+void cCondVar::Wait(cMutex &Mutex)
+{
+  if (Mutex.locked) {
+     int locked = Mutex.locked;
+     Mutex.locked = 0; // have to clear the locked count here, as pthread_cond_wait
+                       // does an implicit unlock of the mutex
+     pthread_cond_wait(&cond, &Mutex.mutex);
+     Mutex.locked = locked;
+     }
+}
+
+bool cCondVar::TimedWait(cMutex &Mutex, int TimeoutMs)
+{
+  bool r = true; // true = condition signaled, false = timeout
+
+  if (Mutex.locked) {
+     struct timespec abstime;
+     if (GetAbsTime(&abstime, TimeoutMs)) {
+        int locked = Mutex.locked;
+        Mutex.locked = 0; // have to clear the locked count here, as pthread_cond_timedwait
+                          // does an implicit unlock of the mutex.
+        if (pthread_cond_timedwait(&cond, &Mutex.mutex, &abstime) == ETIMEDOUT)
+           r = false;
+        Mutex.locked = locked;
+        }
+     }
+  return r;
+}
+
+void cCondVar::Broadcast(void)
+{
+  pthread_cond_broadcast(&cond);
+}
+
+// --- cRwLock ---------------------------------------------------------------
+
+cRwLock::cRwLock(bool PreferWriter)
+{
+  locked = 0;
+  writeLockThreadId = 0;
+  pthread_rwlockattr_t attr;
+  pthread_rwlockattr_init(&attr);
+  pthread_rwlockattr_setkind_np(&attr, PreferWriter ? PTHREAD_RWLOCK_PREFER_WRITER_NP : PTHREAD_RWLOCK_PREFER_READER_NP);
+  pthread_rwlock_init(&rwlock, &attr);
+}
+
+cRwLock::~cRwLock()
+{
+  pthread_rwlock_destroy(&rwlock);
+}
+
+bool cRwLock::Lock(bool Write, int TimeoutMs)
+{
+  int Result = 0;
+  struct timespec abstime;
+  if (TimeoutMs) {
+     if (!GetAbsTime(&abstime, TimeoutMs))
+        TimeoutMs = 0;
+     }
+  if (Write) {
+     Result = TimeoutMs ? pthread_rwlock_timedwrlock(&rwlock, &abstime) : pthread_rwlock_wrlock(&rwlock);
+     if (Result == 0)
+        writeLockThreadId = cThread::ThreadId();
+     }
+  else if (writeLockThreadId == cThread::ThreadId()) {
+     locked++; // there can be any number of stacked read locks, so we keep track here
+     Result = 0; // aquiring a read lock while holding a write lock within the same thread is OK
+     }
+  else
+     Result = TimeoutMs ? pthread_rwlock_timedrdlock(&rwlock, &abstime) : pthread_rwlock_rdlock(&rwlock);
+  return Result == 0;
+}
+
+void cRwLock::Unlock(void)
+{
+  if (writeLockThreadId == cThread::ThreadId()) { // this is the thread that obtained the initial write lock
+     if (locked) { // this is the unlock of a read lock within the write lock
+        locked--;
+        return;
+        }
+     }
+  writeLockThreadId = 0;
+  pthread_rwlock_unlock(&rwlock);
+}
+
+// --- cMutex ----------------------------------------------------------------
+
+cMutex::cMutex(void)
+{
+  locked = 0;
+  pthread_mutexattr_t attr;
+  pthread_mutexattr_init(&attr);
+  pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_ERRORCHECK_NP);
+  pthread_mutex_init(&mutex, &attr);
+}
+
+cMutex::~cMutex()
+{
+  pthread_mutex_destroy(&mutex);
+}
+
+void cMutex::Lock(void)
+{
+  pthread_mutex_lock(&mutex);
+  locked++;
+}
+
+void cMutex::Unlock(void)
+{
+  if (!--locked)
+     pthread_mutex_unlock(&mutex);
+}
+
+// --- cThread ---------------------------------------------------------------
+
+tThreadId cThread::mainThreadId = 0;
+
+cThread::cThread(const char *Description, bool LowPriority)
+{
+  active = running = false;
+  childTid = 0;
+  childThreadId = 0;
+  description = NULL;
+  if (Description)
+     SetDescription("%s", Description);
+  lowPriority = LowPriority;
+}
+
+cThread::~cThread()
+{
+  Cancel(); // just in case the derived class didn't call it
+  free(description);
+}
+
+void cThread::SetPriority(int Priority)
+{
+  if (setpriority(PRIO_PROCESS, 0, Priority) < 0)
+     LOG_ERROR;
+}
+
+void cThread::SetIOPriority(int Priority)
+{
+  if (syscall(SYS_ioprio_set, 1, 0, (Priority & 0xff) | (3 << 13)) < 0) // idle class
+     LOG_ERROR;
+}
+
+void cThread::SetDescription(const char *Description, ...)
+{
+  free(description);
+  description = NULL;
+  if (Description) {
+     va_list ap;
+     va_start(ap, Description);
+     description = strdup(cString::vsprintf(Description, ap));
+     va_end(ap);
+     }
+}
+
+void *cThread::StartThread(cThread *Thread)
+{
+  Thread->childThreadId = ThreadId();
+  if (Thread->description) {
+     dsyslog("%s thread started (pid=%d, tid=%d, prio=%s)", Thread->description, getpid(), Thread->childThreadId, Thread->lowPriority ? "low" : "high");
+#ifdef PR_SET_NAME
+     if (prctl(PR_SET_NAME, Thread->description, 0, 0, 0) < 0)
+        esyslog("%s thread naming failed (pid=%d, tid=%d)", Thread->description, getpid(), Thread->childThreadId);
+#endif
+     }
+  if (Thread->lowPriority) {
+     Thread->SetPriority(19);
+     Thread->SetIOPriority(7);
+     }
+  Thread->Action();
+  if (Thread->description)
+     dsyslog("%s thread ended (pid=%d, tid=%d)", Thread->description, getpid(), Thread->childThreadId);
+  Thread->running = false;
+  Thread->active = false;
+  return NULL;
+}
+
+#define THREAD_STOP_TIMEOUT  3000 // ms to wait for a thread to stop before newly starting it
+#define THREAD_STOP_SLEEP      30 // ms to sleep while waiting for a thread to stop
+
+bool cThread::Start(void)
+{
+  if (!running) {
+     if (active) {
+        // Wait until the previous incarnation of this thread has completely ended
+        // before starting it newly:
+        cTimeMs RestartTimeout;
+        while (!running && active && RestartTimeout.Elapsed() < THREAD_STOP_TIMEOUT)
+              cCondWait::SleepMs(THREAD_STOP_SLEEP);
+        }
+     if (!active) {
+        active = running = true;
+        if (pthread_create(&childTid, NULL, (void *(*) (void *))&StartThread, (void *)this) == 0) {
+           pthread_detach(childTid); // auto-reap
+           }
+        else {
+           LOG_ERROR;
+           active = running = false;
+           return false;
+           }
+        }
+     }
+  return true;
+}
+
+bool cThread::Active(void)
+{
+  if (active) {
+     //
+     // Single UNIX Spec v2 says:
+     //
+     // The pthread_kill() function is used to request
+     // that a signal be delivered to the specified thread.
+     //
+     // As in kill(), if sig is zero, error checking is
+     // performed but no signal is actually sent.
+     //
+     int err;
+     if ((err = pthread_kill(childTid, 0)) != 0) {
+        if (err != ESRCH)
+           LOG_ERROR;
+        childTid = 0;
+        active = running = false;
+        }
+     else
+        return true;
+     }
+  return false;
+}
+
+void cThread::Cancel(int WaitSeconds)
+{
+  running = false;
+  if (active && WaitSeconds > -1) {
+     if (WaitSeconds > 0) {
+        for (time_t t0 = time(NULL) + WaitSeconds; time(NULL) < t0; ) {
+            if (!Active())
+               return;
+            cCondWait::SleepMs(10);
+            }
+        esyslog("ERROR: %s thread %d won't end (waited %d seconds) - canceling it...", description ? description : "", childThreadId, WaitSeconds);
+        }
+     pthread_cancel(childTid);
+     childTid = 0;
+     active = false;
+     }
+}
+
+tThreadId cThread::ThreadId(void)
+{
+  return syscall(__NR_gettid);
+}
+
+void cThread::SetMainThreadId(void)
+{
+  if (mainThreadId == 0)
+     mainThreadId = ThreadId();
+  else
+     esyslog("ERROR: attempt to set main thread id to %d while it already is %d", ThreadId(), mainThreadId);
+}
+
+// --- cMutexLock ------------------------------------------------------------
+
+cMutexLock::cMutexLock(cMutex *Mutex)
+{
+  mutex = NULL;
+  locked = false;
+  Lock(Mutex);
+}
+
+cMutexLock::~cMutexLock()
+{
+  if (mutex && locked)
+     mutex->Unlock();
+}
+
+bool cMutexLock::Lock(cMutex *Mutex)
+{
+  if (Mutex && !mutex) {
+     mutex = Mutex;
+     Mutex->Lock();
+     locked = true;
+     return true;
+     }
+  return false;
+}
+
+// --- cThreadLock -----------------------------------------------------------
+
+cThreadLock::cThreadLock(cThread *Thread)
+{
+  thread = NULL;
+  locked = false;
+  Lock(Thread);
+}
+
+cThreadLock::~cThreadLock()
+{
+  if (thread && locked)
+     thread->Unlock();
+}
+
+bool cThreadLock::Lock(cThread *Thread)
+{
+  if (Thread && !thread) {
+     thread = Thread;
+     Thread->Lock();
+     locked = true;
+     return true;
+     }
+  return false;
+}
+
+// --- cBackTrace ------------------------------------------------------------
+
+#define BT_BUF_SIZE 100
+
+cString cBackTrace::Demangle(char *s)
+{
+  char *Module = s;
+  char *Function = NULL;
+  char *Offset = NULL;
+  char *Address = NULL;
+  // separate the string:
+  for (char *q = Module; *q; q++) {
+      if (*q == '(') {
+         *q = 0;
+         Function = q + 1;
+         }
+      else if (*q == '+') {
+         *q = 0;
+         Offset = q + 1;
+         }
+      else if (*q == ')')
+         *q = 0;
+      else if (*q == '[')
+         Address = q + 1;
+      else if (*q == ']') {
+         *q = 0;
+         break;
+         }
+      }
+  // demangle the function name:
+  char *DemangledFunction = NULL;
+  if (Function) {
+     int status;
+     DemangledFunction = abi::__cxa_demangle(Function, NULL, 0, &status);
+     if (DemangledFunction)
+        Function = DemangledFunction;
+     if (!*Function)
+        Function = NULL;
+     }
+  cString d = cString::sprintf("%s%s%s", Module, Function ? " " : "", Function ? Function : "");
+  // convert string address to numbers:
+  unsigned long long addr = Address ? strtoull(Address, NULL, 0) : 0;
+  unsigned long long offs = Offset ? strtoull(Offset, NULL, 0) : 0;
+  // for shared libraries we need get the offset inside the library:
+  if (Function) {
+     // check whether the module name ends with ".so*":
+     char *e = Module;
+     char *p = NULL;
+     while (e = strstr(e, ".so"))
+           p = e++;
+     if (p && !strchr(p, '/')) {
+        Dl_info dlinfo;
+        if (dladdr(reinterpret_cast<void*>(addr), &dlinfo)) {
+           if ((strcmp(Module, dlinfo.dli_fname) == 0) && dlinfo.dli_fbase) {
+              unsigned long long base = reinterpret_cast<unsigned long long>(dlinfo.dli_fbase);
+              addr -= base;
+              addr &= 0x0FFFFFFFF; // to make it work on both 32 and 64 bit systems
+              }
+           }
+        }
+     }
+  // determine the file name and line number:
+  cString cmd = cString::sprintf("addr2line --functions --demangle --inlines --basename --exe=%s 0x%llx", Module, Function ? addr : offs);
+  cPipe p;
+  if (p.Open(cmd, "r")) {
+     int n = 0;
+     cReadLine rl;
+     while (char *l = rl.Read(p)) {
+           if (n == 0) {
+              if (Function && strcmp(l, Function))
+                 d = cString::sprintf("%s calling %s", *d, l);
+              }
+           else
+              d = cString::sprintf("%s at %s", *d, l);
+           n++;
+           }
+     p.Close();
+     }
+  free(DemangledFunction);
+  return d;
+}
+
+void cBackTrace::BackTrace(cStringList &StringList, int Level, bool Mangled)
+{
+  void *b[BT_BUF_SIZE];
+  int n = backtrace(b, BT_BUF_SIZE);
+  if (char **s = backtrace_symbols(b, n)) {
+     for (int i = max(Level, 0) + 1; i < n; i++) // 1 is the call to this function itself
+         StringList.Append(strdup(Mangled ? s[i] : *Demangle(s[i])));
+     free(s);
+     }
+}
+
+void cBackTrace::BackTrace(FILE *f, int Level, bool Mangled)
+{
+  cStringList sl;
+  BackTrace(sl, Level + 1, Mangled); // 1 is the call to this function itself
+  for (int i = 0; i < sl.Size(); i++) {
+      if (f)
+         fprintf(f, "%s\n", sl[i]);
+      else
+         dsyslog("%s", sl[i]);
+      }
+}
+
+cString cBackTrace::GetCaller(int Level, bool Mangled)
+{
+  cString Caller;
+  Level = max(Level, 0) + 1; // 1 is the call to this function itself
+  void *b[BT_BUF_SIZE];
+  int n = backtrace(b, BT_BUF_SIZE);
+  if (char **s = backtrace_symbols(b, n)) {
+     if (Level < n)
+        Caller = Mangled ? s[Level] : *Demangle(s[Level]);
+     free(s);
+     }
+  return Caller;
+}
+
+// --- cStateLockLog ---------------------------------------------------------
+
+#ifdef DEBUG_LOCKSEQ
+#define SLL_SIZE     20 // the number of log entries
+#define SLL_LENGTH  512 // the maximum length of log entries
+#define SLL_THREADS  20 // the maximum number of threads holding locks at the same time (typically well below 10)
+#define SLL_MAX_LIST  9 // max. number of lists to log
+#define SLL_WRITE_FLAG 0x80000000
+#define SLL_LOCK_FLAG  0x40000000
+
+class cStateLockLog {
+private:
+  cMutex mutex;
+  cVector<tThreadId> threadIds;
+  cVector<int> flags;
+  tThreadId logThreadIds[SLL_SIZE];
+  int logFlags[SLL_SIZE];
+  uint8_t logCounter[SLL_THREADS][SLL_MAX_LIST];
+#ifdef DEBUG_LOCKCALL
+  char logCaller[SLL_SIZE][SLL_LENGTH];
+#endif
+  int logIndex;
+  bool dumped;
+  void Dump(const char *Name, tThreadId ThreadId);
+public:
+  cStateLockLog(void);
+  void Check(const char *Name, bool Lock, bool Write = false);
+  };
+
+cStateLockLog::cStateLockLog(void)
+{
+  memset(logThreadIds, 0, sizeof(logThreadIds));
+  memset(logFlags, 0, sizeof(logFlags));
+  memset(logCounter, 0, sizeof(logCounter));
+#ifdef DEBUG_LOCKCALL
+  memset(logCaller, 0, sizeof(logCaller));
+#endif
+  logIndex = 0;
+  dumped = false;
+}
+
+void cStateLockLog::Dump(const char *Name, tThreadId ThreadId)
+{
+  dsyslog("--- begin invalid lock sequence report");
+  int LastFlags = 0;
+  for (int i = 0; i < SLL_SIZE; i++) {
+      if (tThreadId tid = logThreadIds[logIndex]) {
+         char msg[SLL_LENGTH];
+         char *q = msg;
+         q += sprintf(q, "%5d", tid);
+         int Flags = logFlags[logIndex];
+         bool Write = Flags & SLL_WRITE_FLAG;
+         bool Lock = Flags & SLL_LOCK_FLAG;
+         Flags &= ~(SLL_WRITE_FLAG | SLL_LOCK_FLAG);
+         int Changed = LastFlags ^ Flags;
+         LastFlags = Flags;
+         for (int i = 0; i <= SLL_MAX_LIST; i++) {
+             char c = '-';
+             int b = 1 << i;
+             if ((Flags & b) != 0)
+                c = '*';
+             if ((Changed & b) != 0)
+                c = Lock ? Write ? 'W' : 'R' : 'U';
+             q += sprintf(q, "  %c", c);
+             }
+         q += sprintf(q, "  %c", Lock ? 'L' : 'U');
+#ifdef DEBUG_LOCKCALL
+         if (*logCaller[logIndex]) {
+            *q++ = ' ';
+            strn0cpy(q, *cBackTrace::Demangle(logCaller[logIndex]), sizeof(msg) - (q - msg));
+            }
+#endif
+         dsyslog("%s", msg);
+         }
+      if (++logIndex >= SLL_SIZE)
+         logIndex = 0;
+      }
+  dsyslog("%5d invalid lock sequence: %s", ThreadId, Name);
+  dsyslog("full backtrace:");
+  cBackTrace::BackTrace(NULL, 2);
+  dsyslog("--- end invalid lock sequence report");
+  dsyslog("--- THERE WILL BE NO FURTHER REPORTS UNTIL VDR IS RESTARTED!");
+  fprintf(stderr, "invalid lock sequence at %s\n", *DayDateTime(time(NULL)));
+}
+
+void cStateLockLog::Check(const char *Name, bool Lock, bool Write)
+{
+  if (!dumped && Name) {
+     int n = *Name - '0' - 1;
+     if (0 <= n && n < SLL_MAX_LIST) {
+        int b = 1 << n;
+        cMutexLock MutexLock(&mutex);
+        tThreadId ThreadId = cThread::ThreadId();
+        int Index = -1;
+        int AvailableIndex = -1;
+        for (int i = 0; i < threadIds.Size(); i++) {
+            if (ThreadId == threadIds[i]) {
+               Index = i;
+               break;
+               }
+            if (threadIds[i] == 0)
+               AvailableIndex = i;
+            }
+        if (Index < 0) {
+           if (AvailableIndex < 0) {
+              Index = threadIds.Size();
+              threadIds.Append(ThreadId);
+              flags.Append(0);
+              }
+           else {
+              Index = AvailableIndex;
+              threadIds[Index] = ThreadId;
+              }
+           }
+        if (Index >= SLL_THREADS) {
+           // should never happen!
+           esyslog("ERROR: too many threads holding list locks at the same time - stopped logging locks!");
+           dumped = true;
+           return;
+           }
+        bool DoDump = false;
+        if (Lock) {
+           if ((flags[Index] & ~b) < b) // thread holds only "smaller" locks -> OK
+              ;
+           else if ((flags[Index] & b) == 0) // thread already holds "bigger" locks, so it may only re-lock one that it already has!
+              DoDump = true;
+           logCounter[Index][n]++;
+           flags[Index] |= b;
+           }
+        else if (--logCounter[Index][n] == 0)
+           flags[Index] &= ~b;
+        logThreadIds[logIndex] = ThreadId;
+        logFlags[logIndex] = flags[Index] | (Write ? SLL_WRITE_FLAG : 0) | (Lock ? SLL_LOCK_FLAG : 0);
+        if (flags[Index] == 0)
+           threadIds[Index] = 0;
+#ifdef DEBUG_LOCKCALL
+        strn0cpy(logCaller[logIndex], cBackTrace::GetCaller(Lock ? 3 : 5, true), SLL_LENGTH);
+#endif
+        if (++logIndex >= SLL_SIZE)
+           logIndex = 0;
+        if (DoDump) {
+           //Dump(Name, ThreadId);
+           dumped = true;
+           }
+        }
+     }
+}
+
+static cStateLockLog StateLockLog;
+
+#define dbglockseq(n, l, w) StateLockLog.Check(n, l, w)
+#else
+#define dbglockseq(n, l, w)
+#endif // DEBUG_LOCKSEQ
+
+// --- cStateLock ------------------------------------------------------------
+
+cStateLock::cStateLock(const char *Name)
+:rwLock(true)
+{
+  name = Name;
+  threadId = 0;
+  state = 0;
+  explicitModify = emDisabled;
+  syncStateKey = NULL;
+}
+
+bool cStateLock::Lock(cStateKey &StateKey, bool Write, int TimeoutMs)
+{
+  dbglocking("%5d %-12s %10p   lock state = %d/%d write = %d timeout = %d\n", cThread::ThreadId(), name, &StateKey, state, StateKey.state, Write, TimeoutMs);
+  StateKey.timedOut = false;
+  if (StateKey.stateLock) {
+     esyslog("ERROR: StateKey already in use in call to cStateLock::Lock() (tid=%d, lock=%s)", StateKey.stateLock->threadId, name);
+     ABORT;
+     return false;
+     }
+  if (rwLock.Lock(Write, TimeoutMs)) {
+     dbglockseq(name, true, Write);
+     StateKey.stateLock = this;
+     if (Write) {
+        dbglocking("%5d %-12s %10p   locked write\n", cThread::ThreadId(), name, &StateKey);
+        threadId = cThread::ThreadId();
+        StateKey.write = true;
+        return true;
+        }
+     else if (state != StateKey.state) {
+        dbglocking("%5d %-12s %10p   locked read\n", cThread::ThreadId(), name, &StateKey);
+        return true;
+        }
+     else {
+        dbglocking("%5d %-12s %10p   state unchanged\n", cThread::ThreadId(), name, &StateKey);
+        StateKey.stateLock = NULL;
+        dbglockseq(name, false, false);
+        rwLock.Unlock();
+        }
+     }
+  else if (TimeoutMs) {
+     dbglocking("%5d %-12s %10p   timeout\n", cThread::ThreadId(), name, &StateKey);
+     StateKey.timedOut = true;
+     }
+  return false;
+}
+
+void cStateLock::Unlock(cStateKey &StateKey, bool IncState)
+{
+  dbglocking("%5d %-12s %10p unlock state = %d/%d inc = %d\n", cThread::ThreadId(), name, &StateKey, state, StateKey.state, IncState);
+  if (StateKey.stateLock != this) {
+     esyslog("ERROR: cStateLock::Unlock() called with an unused key (tid=%d, lock=%s)", threadId, name);
+     ABORT;
+     return;
+     }
+  if (StateKey.write && threadId != cThread::ThreadId()) {
+     esyslog("ERROR: cStateLock::Unlock() called without holding a write lock (tid=%d, lock=%s)", threadId, name);
+     ABORT;
+     return;
+     }
+  if (StateKey.write && (IncState && explicitModify != emArmed || explicitModify == emEnabled)) {
+     if (syncStateKey && syncStateKey->state == state)
+        syncStateKey->state++;
+     state++;
+     }
+  StateKey.state = state;
+  StateKey.stateLock = NULL;
+  if (StateKey.write) {
+     StateKey.write = false;
+     threadId = 0;
+     explicitModify = emDisabled;
+     syncStateKey = NULL;
+     }
+  dbglockseq(name, false, false);
+  rwLock.Unlock();
+}
+
+void cStateLock::SetSyncStateKey(cStateKey &StateKey)
+{
+  dbglocking("%5d %-12s %10p SetSyncStateKey\n", cThread::ThreadId(), name, &StateKey);
+  if (threadId != cThread::ThreadId()) {
+     esyslog("ERROR: cStateLock::SetSyncStateKey() called without holding a write lock (tid=%d, lock=%s)", threadId, name);
+     ABORT;
+     return;
+     }
+  if (StateKey.stateLock == this) {
+     esyslog("ERROR: cStateLock::SetSyncStateKey() called with locked key (tid=%d, lock=%s)", threadId, name);
+     ABORT;
+     return;
+     }
+  if (syncStateKey) {
+     esyslog("ERROR: cStateLock::SetSyncStateKey() called twice (tid=%d, lock=%s)", threadId, name);
+     ABORT;
+     return;
+     }
+  syncStateKey = &StateKey;
+}
+
+void cStateLock::SetExplicitModify(void)
+{
+  if (threadId != cThread::ThreadId()) {
+     esyslog("ERROR: cStateLock::SetExplicitModify() called without holding a write lock (tid=%d, lock=%s)", threadId, name);
+     ABORT;
+     return;
+     }
+  if (explicitModify != emDisabled) {
+     esyslog("ERROR: cStateLock::SetExplicitModify() called twice (tid=%d, lock=%s)", threadId, name);
+     ABORT;
+     return;
+     }
+  explicitModify = emArmed;
+}
+
+void cStateLock::SetModified(void)
+{
+  if (threadId != cThread::ThreadId()) {
+     esyslog("ERROR: cStateLock::SetModified() called without holding a write lock (tid=%d, lock=%s)", threadId, name);
+     ABORT;
+     return;
+     }
+  explicitModify = emEnabled;
+}
+
+// --- cStateKey -------------------------------------------------------------
+
+cStateKey::cStateKey(bool IgnoreFirst)
+{
+  stateLock = NULL;
+  write = false;
+  state = 0;
+  if (!IgnoreFirst)
+     Reset();
+}
+
+cStateKey::~cStateKey()
+{
+  if (stateLock) {
+     esyslog("ERROR: cStateKey::~cStateKey() called without releasing the lock first (tid=%d, lock=%s, key=%p)", stateLock->threadId, stateLock->name, this);
+     ABORT;
+     }
+}
+
+void cStateKey::Reset(void)
+{
+  state = -1; // lock and key are initialized differently, to make the first check return true
+}
+
+void cStateKey::Remove(bool IncState)
+{
+  if (stateLock)
+     stateLock->Unlock(*this, IncState);
+  else {
+     esyslog("ERROR: cStateKey::Remove() called without holding a lock (key=%p)", this);
+     ABORT;
+     }
+}
+
+bool cStateKey::StateChanged(void)
+{
+  if (!stateLock) {
+     esyslog("ERROR: cStateKey::StateChanged() called without holding a lock (tid=%d, key=%p)", cThread::ThreadId(), this);
+     ABORT;
+     }
+  else if (write)
+     return state != stateLock->state;
+  else
+     return true;
+}
+
+// --- cIoThrottle -----------------------------------------------------------
+
+cMutex cIoThrottle::mutex;
+int cIoThrottle::count = 0;
+
+cIoThrottle::cIoThrottle(void)
+{
+  active = false;
+}
+
+cIoThrottle::~cIoThrottle()
+{
+  Release();
+}
+
+void cIoThrottle::Activate(void)
+{
+  if (!active) {
+     mutex.Lock();
+     count++;
+     active = true;
+     dsyslog("i/o throttle activated, count = %d (tid=%d)", count, cThread::ThreadId());
+     mutex.Unlock();
+     }
+}
+
+void cIoThrottle::Release(void)
+{
+  if (active) {
+     mutex.Lock();
+     count--;
+     active = false;
+     dsyslog("i/o throttle released, count = %d (tid=%d)", count, cThread::ThreadId());
+     mutex.Unlock();
+     }
+}
+
+bool cIoThrottle::Engaged(void)
+{
+  return count > 0;
+}
+
+// --- cPipe -----------------------------------------------------------------
+
+// cPipe::Open() and cPipe::Close() are based on code originally received from
+// Andreas Vitting <Andreas@huji.de>
+
+cPipe::cPipe(void)
+{
+  pid = -1;
+  f = NULL;
+}
+
+cPipe::~cPipe()
+{
+  Close();
+}
+
+bool cPipe::Open(const char *Command, const char *Mode)
+{
+  int fd[2];
+
+  if (pipe(fd) < 0) {
+     LOG_ERROR;
+     return false;
+     }
+  if ((pid = fork()) < 0) { // fork failed
+     LOG_ERROR;
+     close(fd[0]);
+     close(fd[1]);
+     return false;
+     }
+
+  const char *mode = "w";
+  int iopipe = 0;
+
+  if (pid > 0) { // parent process
+     if (strcmp(Mode, "r") == 0) {
+        mode = "r";
+        iopipe = 1;
+        }
+     close(fd[iopipe]);
+     if ((f = fdopen(fd[1 - iopipe], mode)) == NULL) {
+        LOG_ERROR;
+        close(fd[1 - iopipe]);
+        }
+     return f != NULL;
+     }
+  else { // child process
+     int iofd = STDOUT_FILENO;
+     if (strcmp(Mode, "w") == 0) {
+        iopipe = 1;
+        iofd = STDIN_FILENO;
+        }
+     close(fd[iopipe]);
+     if (dup2(fd[1 - iopipe], iofd) == -1) { // now redirect
+        LOG_ERROR;
+        close(fd[1 - iopipe]);
+        _exit(-1);
+        }
+     else {
+        int MaxPossibleFileDescriptors = getdtablesize();
+        for (int i = STDERR_FILENO + 1; i < MaxPossibleFileDescriptors; i++)
+            close(i); //close all dup'ed filedescriptors
+        if (execl("/bin/sh", "sh", "-c", Command, NULL) == -1) {
+           LOG_ERROR_STR(Command);
+           close(fd[1 - iopipe]);
+           _exit(-1);
+           }
+        }
+     _exit(0);
+     }
+}
+
+int cPipe::Close(void)
+{
+  int ret = -1;
+
+  if (f) {
+     fclose(f);
+     f = NULL;
+     }
+
+  if (pid > 0) {
+     int status = 0;
+     int i = 5;
+     while (i > 0) {
+           ret = waitpid(pid, &status, WNOHANG);
+           if (ret < 0) {
+              if (errno != EINTR && errno != ECHILD) {
+                 LOG_ERROR;
+                 break;
+                 }
+              }
+           else if (ret == pid)
+              break;
+           i--;
+           cCondWait::SleepMs(100);
+           }
+     if (!i) {
+        kill(pid, SIGKILL);
+        ret = -1;
+        }
+     else if (ret == -1 || !WIFEXITED(status))
+        ret = -1;
+     pid = -1;
+     }
+
+  return ret;
+}
+
+// --- SystemExec ------------------------------------------------------------
+
+int SystemExec(const char *Command, bool Detached)
+{
+  pid_t pid;
+
+  if ((pid = fork()) < 0) { // fork failed
+     LOG_ERROR;
+     return -1;
+     }
+
+  if (pid > 0) { // parent process
+     int status = 0;
+     if (waitpid(pid, &status, 0) < 0) {
+        LOG_ERROR;
+        return -1;
+        }
+     return status;
+     }
+  else { // child process
+     if (Detached) {
+        // Fork again and let first child die - grandchild stays alive without parent
+        if (fork() > 0)
+           _exit(0);
+        // Start a new session
+        pid_t sid = setsid();
+        if (sid < 0)
+           LOG_ERROR;
+        // close STDIN and re-open as /dev/null
+        int devnull = open("/dev/null", O_RDONLY);
+        if (devnull < 0 || dup2(devnull, 0) < 0)
+           LOG_ERROR;
+        }
+     int MaxPossibleFileDescriptors = getdtablesize();
+     for (int i = STDERR_FILENO + 1; i < MaxPossibleFileDescriptors; i++)
+         close(i); //close all dup'ed filedescriptors
+     if (execl("/bin/sh", "sh", "-c", Command, NULL) == -1) {
+        LOG_ERROR_STR(Command);
+        _exit(-1);
+        }
+     _exit(0);
+     }
+}
diff -Naurp vdr-2.4.0/vdr.c vdr-2.4.0-patch/vdr.c
--- vdr-2.4.0/vdr.c	2018-04-16 11:03:57.000000000 +0300
+++ vdr-2.4.0-patch/vdr.c	2018-04-16 11:04:41.000000000 +0300
@@ -39,6 +39,7 @@
 #endif
 #include <termios.h>
 #include <unistd.h>
+#include <fcntl.h>
 #include "args.h"
 #include "audio.h"
 #include "channels.h"
@@ -76,9 +77,9 @@
 #define ACTIVITYTIMEOUT       60 // seconds before starting housekeeping
 #define SHUTDOWNWAIT         300 // seconds to wait in user prompt before automatic shutdown
 #define SHUTDOWNRETRY        360 // seconds before trying again to shut down
-#define SHUTDOWNFORCEPROMPT    5 // seconds to wait in user prompt to allow forcing shutdown
-#define SHUTDOWNCANCELPROMPT   5 // seconds to wait in user prompt to allow canceling shutdown
-#define RESTARTCANCELPROMPT    5 // seconds to wait in user prompt before restarting on SIGHUP
+#define SHUTDOWNFORCEPROMPT    3 // seconds to wait in user prompt to allow forcing shutdown
+#define SHUTDOWNCANCELPROMPT   3 // seconds to wait in user prompt to allow canceling shutdown
+#define RESTARTCANCELPROMPT    3 // seconds to wait in user prompt before restarting on SIGHUP
 #define MANUALSTART          600 // seconds the next timer must be in the future to assume manual start
 #define CHANNELSAVEDELTA     120 // seconds before saving channels.conf after automatic modifications
 #define DEVICEREADYTIMEOUT    30 // seconds to wait until all devices are ready
@@ -1346,7 +1347,7 @@ int main(int argc, char *argv[])
                isyslog("Power button pressed");
                DELETE_MENU;
                // Check for activity, request power button again if active:
-               if (!ShutdownHandler.ConfirmShutdown(false) && Skins.Message(mtWarning, tr("VDR will shut down later - press Power to force"), SHUTDOWNFORCEPROMPT) != kPower) {
+               if (!ShutdownHandler.ConfirmShutdown(false) && Skins.Message(mtWarning, tr("MediaCenter will shut down later - press Power to force"), SHUTDOWNFORCEPROMPT) != kPower) {
                   // Not pressed power - set VDR to be non-interactive and power down later:
                   ShutdownHandler.SetUserInactive();
                   break;
@@ -1368,6 +1369,66 @@ int main(int argc, char *argv[])
                // Do not attempt to automatically shut down for a while:
                ShutdownHandler.SetRetry(SHUTDOWNRETRY);
                break;
+          // Exit to KODI:
+          case kExit:
+               isyslog("Exit button pressed");
+               DELETE_MENU;
+               // Check for activity, request exit button again if active:
+               if (!ShutdownHandler.ConfirmShutdown(false) && Skins.Message(mtWarning, tr("VDR will close later - press Exit to force"), SHUTDOWNFORCEPROMPT) != kExit) {
+                  // Not pressed exit - set VDR to be non-interactive and exit later:
+                  ShutdownHandler.SetUserInactive();
+                  break;
+                  }
+               // No activity or exit button pressed twice - ask for confirmation:
+               if (!ShutdownHandler.ConfirmShutdown(true)) {
+                  // Non-confirmed background activity - set VDR to be non-interactive and exit down later:
+                  ShutdownHandler.SetUserInactive();
+                  break;
+                  }
+               // Ask the final question:
+               if (!Interface->Confirm(tr("Press any key to cancel exit"), SHUTDOWNCANCELPROMPT, true))
+                  // If final question was canceled, continue to be active:
+                  break;
+               // Ok, now call the exit script:
+               remove("/var/lock/start.vdr");
+               creat("/var/lock/start.kodi", S_IRUSR|S_IROTH);
+               esyslog("VDR frontend key command: Exit");
+               EXIT(0);
+               // Set VDR to be non-interactive and exit down again later:
+               ShutdownHandler.SetUserInactive();
+               // Do not attempt to automatically exit for a while:
+               ShutdownHandler.SetRetry(SHUTDOWNRETRY);
+               break;
+          // Sleep:
+          case kSleep:
+               isyslog("Sleep button pressed");
+               DELETE_MENU;
+               // Check for activity, request exit button again if active:
+               if (!ShutdownHandler.ConfirmShutdown(false) && Skins.Message(mtWarning, tr("MediaCenter will sleep later - press Sleep to force"), SHUTDOWNFORCEPROMPT) != kSleep) {
+                  // Not pressed sleep - set VDR to be non-interactive and sleep later:
+                  ShutdownHandler.SetUserInactive();
+                  break;
+                  }
+               // No activity or sleep button pressed twice - ask for confirmation:
+               if (!ShutdownHandler.ConfirmShutdown(true)) {
+                  // Non-confirmed background activity - set VDR to be non-interactive and sleep down later:
+                  ShutdownHandler.SetUserInactive();
+                  break;
+                  }
+               // Ask sleep question:
+               if (!Interface->Confirm(tr("Press any key to cancel sleep"), SHUTDOWNCANCELPROMPT, true))
+                  // If final question was canceled, continue to be active:
+                  break;
+               // Ok, now call the sleep script:
+               remove("/var/lock/start.vdr");
+               creat("/var/lock/sleep.vdr", S_IRUSR|S_IROTH);
+               esyslog("VDR frontend key command: Sleep");
+               EXIT(97);
+               // Set VDR to be non-interactive and sleep again later:
+               ShutdownHandler.SetUserInactive();
+               // Do not attempt to automatically sleep for a while:
+               ShutdownHandler.SetRetry(SHUTDOWNRETRY);
+               break;
           default: break;
           }
         Interact = Menu ? Menu : cControl::Control(); // might have been closed in the mean time
@@ -1605,5 +1666,26 @@ Exit:
   else
      sd_notify(0, "STOPPING=1\nSTATUS=Exiting");
 #endif
+
+  // Success EXIT code
+  switch(ShutdownHandler.GetExitCode()) {
+     case 0: // Exit to Kodi
+         esyslog("VDR frontend normal Exit!!!");
+         SystemExec("systemctl stop vdr.service", false);
+         break;
+     case 97: // Sleep
+         esyslog("VDR frontend normal Suspend!!!");
+         SystemExec("systemctl stop vdr.service", false);
+         break;
+     case 98: // Reboot
+         esyslog("VDR frontend normal Reboot!!!");
+         SystemExec("systemctl stop vdr.service", false);
+         break;
+     case 99: // Shutdown
+         esyslog("VDR frontend normal PowerOff!!!");
+         SystemExec("systemctl stop vdr.service", false);
+         break;
+    }
+
   return ShutdownHandler.GetExitCode();
 }
diff -Naurp vdr-2.4.0/vdr.c.orig vdr-2.4.0-patch/vdr.c.orig
--- vdr-2.4.0/vdr.c.orig	2018-04-16 11:03:57.000000000 +0300
+++ vdr-2.4.0-patch/vdr.c.orig	2018-04-16 11:04:41.000000000 +0300
@@ -768,12 +768,6 @@ int main(int argc, char *argv[])
   Folders.Load(AddDirectory(ConfigDirectory, "folders.conf"));
   CamResponsesLoad(AddDirectory(ConfigDirectory, "camresponses.conf"), true);
 
-  if (!*cFont::GetFontFileName(Setup.FontOsd)) {
-     const char *msg = "no fonts available - OSD will not show any text!";
-     fprintf(stderr, "vdr: %s\n", msg);
-     esyslog("ERROR: %s", msg);
-     }
-
   // Recordings:
 
   cRecordings::Update();
@@ -848,8 +842,6 @@ int main(int argc, char *argv[])
   // Default skins:
 
   new cSkinLCARS;
-  new cSkinSTTNG;
-  new cSkinClassic;
   Skins.SetCurrent(Setup.OSDSkin);
   cThemes::Load(Skins.Current()->Name(), Setup.OSDTheme, Skins.Current()->Theme());
   CurrentSkin = Skins.Current();
